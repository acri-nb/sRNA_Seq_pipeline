---
title: "derfinder_report"
author: "EAllain"
date: "`r Sys.Date()`"
output: html_document
---
### small RNAseq report for Derfinder and Excerpt. 
The exceRpt pipeline hierarchically maps reads to various RNA type databases, prioritizing miRNA > 

see https://www.cell.com/cell-systems/pdfExtended/S2405-4712(19)30074-2 for details

```{r setup}
library(edgeR)
library(RColorBrewer)
library(pheatmap)
library(viridis)

#The clean version should be callable with  R -e "rmarkdown::render('test.rmd')" --args X Y Z

args<-commandArgs(TRUE)
if(length(args) < 5){
  
  ## if no data directory is specified, throw an error message
  cat("\nERROR: no input data specified!\n\n")
  cat("Usage: Rscript excerpt_DE.R <ReadCounts.RData object> <Design_table> <filter_in_cpm> <reference_level> <treatment_level>\n\n")
  
}else{
  #load the count matrix generated by the excerpt pipeline
  load(args[1])
  total <- round(df_1, digits=0)
  #create design matrix
  design <- read.table(args[2], sep = "\t", header = T, row.names = 1)
  #design <- design[order(rownames(design)),,drop=FALSE]
  total <- total[,colnames(total) %in% rownames(design)]
  total <- as.data.frame(total)[, rownames(design)]
  total <- as.matrix(total)
  
  nsamples <- dim(design)[1]
  filt <- as.integer(args[3])
  
  design$Condition <- factor(design$Condition, levels = c(args[4], args[5]))
  design.matrix <- model.matrix(~ Condition,data=design)
  
  DGEobj <- DGEList(counts=total,genes=row.names(total))
  colors=as.factor(design$Condition)
}
```

## Diagnostic plots

Some plots will be generated that summarize:
* the data distribution pre / post filtering and after normalization
* the biological coefficient of variation

```{r diagnostics}
barplot(DGEobj$samples$lib.size,col=colors,legend = TRUE)
  
#density distribution to check distribution of reads and lib sizes before normalization
pseudo_counts <- log2(DGEobj$counts+1)
i=1
par (mfrow=c(1,1))
plot(density(pseudo_counts[,i]),main="Count distribution - all samples",col=colors[i])
for (i in 2:nsamples)
  lines(density(pseudo_counts[,i]),lwd=2,col=colors[i])

keep <- which(rowSums(cpm(DGEobj)>filt) >= length(design$Condition)/2)
DGEobj <- DGEobj[keep,]

print(c("Genes after Filtering: ", dim(DGEobj$counts)[1]))

pseudo_counts <- log2(DGEobj$counts+1)
i=1
par (mfrow=c(1,1))
plot(density(pseudo_counts[,i]),main="Count distribution - all samples",col=colors[i])
for (i in 2:nsamples)
  lines(density(pseudo_counts[,i]),lwd=2,col=colors[i])

```

Scaling factors / normalization is then performed on the data using the TMM method. This is performed to ensure that samples are comparable between echother. Typically TMM or quantile normalization is performed on sequencing data to ensure that distributional assumptions are met and that library sizes are taken into account when analyzing RNAseq data. 

```{r pressure, echo=FALSE}
#normalization with TMM
DGEobj <- calcNormFactors(DGEobj,method = "TMM")
pseudo_TMM <- log2(scale(DGEobj$counts,center=FALSE,scale=DGEobj$samples$norm.factors)+1)

i=1
par (mfrow=c(1,1))
plot(density(pseudo_TMM[,i]),main="Count distribution - all samples",col=colors[i])
for (i in 2:nsamples)
  lines(density(pseudo_TMM[,i]),lwd=2,col=colors[i])
```

We can now perform Singular Vector Decomposition (SVD) on the resulting matrix and project the data onto the two first principal components. This is equivalent to Principal Component Analysis. 

```{r SVD}
covariables <- colnames(design)

pseudo_counts_cen <-pseudo_TMM - rowMeans(pseudo_TMM)
svd1<-svd(pseudo_counts_cen)
svd_percent<-(svd1$d^2/sum(svd1$d^2))
plot(svd_percent,main="% variance explained",col=2)
par(mfrow=c(length(colnames(design)),1))
for(item in covariables){
  plot(svd1$v[,1],svd1$v[,2],ylab="2nd PC",xlab="1st PC",col=as.factor(design[[item]]), main=item)
  legend("bottomright", legend=unique(design[[item]]),col=seq(1,length(unique(design[[item]]))), pch=1, cex=0.8)
}

```

Dispersion Estimates and biological coefficient of variation (BCV) can then be calculated. The BCV represents the expected variability between samples for a feature / gene. For example: A BCV of 0.42 can be interpreted as expecting a quantitative measurement for a given gene to vary 42% up or down between samples. Dispersion is the square of the BCV and is measured for each individual feature. 

E.g. if genes expression typically differs from replicate to replicate by 20% its BCV is 0.2, and its dispersion is 0.04.

Genes with very low abundance in a given experiment tend to have a high dispersion, because they are close to 0. This is why we tend to filter them out in previous steps.

```{r Dispersion_BCV}
###DE analysis
#dispersion estimation and differential expression
DGEobj <- estimateGLMCommonDisp(DGEobj,design.matrix)
DGEobj <- estimateGLMTrendedDisp(DGEobj,design.matrix)
DGEobj <- estimateGLMTagwiseDisp(DGEobj,design.matrix)

plotBCV(DGEobj, main = paste0("BCV plot"))
```

Afterwards, we can perform our statistical analysis. This part can be tweaked to include multiple independant variables. We only include the main variable of interest (Condition) at first pass. The model is fit to the data and the Likeliehood Ratios Test is employed to generate our final results table that includes our Fold-changes in log2 scale and benjamini-Hochberg adjusted P-values. 

Our default threshold for significance is 0.05, which can also be changed when appropriate. We also check the raw P-Value distribution in a histogram to make sure there are no problems with the analysis. We excpect either a uniform distribution or a right-tailed one. 

```{r Stats}

fit <- glmFit(DGEobj,design.matrix)
design.matrix

#coef choose what coficient , in most cases coef=2 with simple designs, otherwise the coeficient and design will need to be adjusted. Model comparison is encouraged. 
res <- glmLRT(fit,coef=2)
#generates a table of DE results for all genes after filtering
final <- topTags(res,n=nrow(DGEobj$counts))
results <- final$table
results <- results[order(rownames(results)),]
head(results)
hist(results$PValue)
ncnts <- scale(DGEobj$counts,center=FALSE,scale=DGEobj$samples$norm.factors)
ncnts <- ncnts[order(rownames(ncnts)),]
results <- cbind(results, ncnts)
write.table(results, paste(toString(args[1]), "_Analysis.txt", sep = ""), sep = "\t")

```


Information about tools versions, etc.

```{r Info}
sessionInfo()
```
