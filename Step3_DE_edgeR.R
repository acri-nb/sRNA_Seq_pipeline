library(edgeR)
library(RColorBrewer)
library(pheatmap)
library(RColorBrewer)
library(viridis)

#load the count matrix generated by the derfinder pipeline (Step2)
total <- read.table("total_lung.tsv")

#create data frame with only columns with count data
count <- round(as.data.frame(total[,4:20]))


#create design matrix, in this case 3 conditions
design <- data.frame(row.names= colnames(count),sample= colnames(count),condition=c(rep("control",3),"adenocarcinoma",rep("COPD",4),rep("adenocarcinoma",6),rep("control",3)))

##the order of the levels stabilish what are the comparisions that can be done, in this case the condition control is the reference, so the possibilities are:
#Control x Adenocarcioma and Control x COPD, if you want to do for example adenocarcinoma x COPD, you need to put adenocarcinoma as first level in the design.matrix
#in this case here are the columns of the design.matrix: (Intercept) conditionadenocarcinoma conditionCOPD
design$condition <- factor(design$condition,levels=c("control","adenocarcinoma","COPD"))
design.matrix <- model.matrix(~ condition,data=design)


#if you want to include batches in the design, perform this if you want to fix batching effect
design_2 <- design
design_2$batch <- "b1"
design_2$batch[c(6,7,8,10,14,15)] <- "b2"
design_2$condition <-factor(design_2$condition,levels=c("control","adenocarcinoma","COPD"))
design_2$batch <- factor (design_2$batch, levels=c("b1","b2"))
design.matrix_2 <- model.matrix(~condition + batch + condition:batch,data=design_2)



#edgeR object creation, using count matrix, genes = names of the genes
y <- DGEList(counts=count,genes=row.names(count))

#edgeR object with batching groups
yB <- DGEList(counts=y2$counts, group=design_2$condition:design_2$batch)


#to visualize library size barplot
barplot(y$samples$lib.size,col=col_vector,legend = TRUE)

#boxplot to check distribution of reads before normalization
boxplot(y$counts)
legend(x = "topright", legend = rownames(y$samples), fill = col_vector, bty = "n", y.intersp = 2)


#filter of low expressed genes, to remove 0 and low counts, removing only low count genes in ALL conditions
keep <- which((rowSums(count[,c(1:3,15:17)] > 10) > 3) | ((rowSums(count[,c(4,9:14)] > 10) > 3)|(rowSums(count[,c(5:8)] > 10) > 2)))

#implementing the filter to the edgeR opgject
y2 <- y[keep,]

#adding a number for each condition 
y2$samples$group = c(1,1,1,2,3,3,3,3,2,2,2,2,2,2,1,1,1)

#normalization with TMM
y2 <- calcNormFactors(y2,method = "TMM")
##to plot MDS , to check variability (type of PCA)
plotMDS(y2[,c(1:4,9:16)],dim.plot = c(1,2))

###DE analysis
#dispersion estimation and differential expression
y2 <- estimateGLMCommonDisp(y2,design.matrix)
y2 <- estimateGLMTrendedDisp(y2,design.matrix)
y2 <- estimateGLMTagwiseDisp(y2,design.matrix)
fit <- glmFit(y2,design.matrix)
#coef choose what coficient , in this case 2 is Control x adenocarcioma, and 3 is Control x COPD
res <- glmLRT(fit,coef=2)
#generates a table of DE results for all genes after filtering
final <- topTags(res,n=nrow(y2$counts))
##for batching effect DE
yB <- estimateGLMCommonDisp(yB,design.matrix_2)
yB <- estimateGLMTrendedDisp(yB,design.matrix_2)
yB <- estimateGLMTagwiseDisp(yB,design.matrix_2)
fitB <- glmFit(yB,design.matrix_2)
qlf <- glmLRT(fitB,coef="conditionadenocarcinoma")
qlf2 <- glmLRT(fitB,coef="conditionCOPD")
results_aB <- topTags(qlf,nrow(yB$counts))
results_cB <- topTags(qlf2,nrow(yB$counts))


###reate dataframe for the final results
#dataframe with raw and normalized counts
results <- cbind(round(y2$counts),log2(scale(y2$counts,center=FALSE,scale=y2$samples$norm.factors)+1))
#another data frame with the counts plus the DE results
results2 <- merge(results,final$table,by="row.names")
#adding the derfinder annotation information to the results final table
results2 <- cbind(results2, total[results2$Row.names,21:23])

###generate heatmap
#filter only FDR <0.05 results
res_FDR_filtered <- results2[which(results2$FDR.x < 0.05 | results2$FDR.y < 0.05),]
matrix_heat <- as.matrix(res_FDR_filtered[,19:35])
pheatmap(log2(matrix_heat+1/rowMeans(matrix_heat+1))-2,breaks=c(seq(-3,-1,length=100),seq(-0.9,0.9,length=100), seq(1,3,length=100)),color=bluered(299),  show_rownames = FALSE,annotation_col    = mat_col)

###upset plots

##use output of perl script for binary production
tnbc <- read.table("binary.txt",header=T)
library(UpSetR)
pdf("tnbc.pdf")
upset(tnbc,nset=8,keep.order=T,nintersects = 62,set_size.show=F)
upset(tbinary,nset=8,keep.order=T,nintersects = 200,set_size.show=F, show.numbers = F)
dev.off()

##combinatory matrix of relationships
library(ComplexHeatmap)
comb2 <- make_comb_mat(binary)

head(comb2)
write.table(comb_size(comb2),file="combinations.tsv")
comb_size(comb2)

